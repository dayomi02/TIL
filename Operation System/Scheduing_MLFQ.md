#### Multi-Level Feedback Queue (MLFQ)

- 미래를 예측하기 위해 과거로부터 학습하는 스케쥴러

- 목표 :

  - 반환 시간 최적화 → 짧은 작업 먼저 실행

  - 작업 길이에 대한 사전 지식 없이 응담 시간 최소화

    

------



#### MLFQ: Basic Rules

- MLFQ에는 여러 개의 고유한 큐가 있다.

  각 큐에는 서로 다른 우선 순위 수준이 할당된다.

- 실행할 준비가 된 작업이 싱글 큐에 있다.

  - 높은 큐의 작업이 실행되도록 선택된다.
  - 동일한 대기열의 작업 간에는 라운드 로빈 스케쥴링을 사용함.

- MLFQ는 관찰된 동작에 따라 작업의 우선순위를 변경한다.

- Example:

  - 작업이 IO를 기다리는 동안 CPU를 반복적으로 포기함

    → 우선 순위를 높게 유지

  - 작업이 장시간 CPU를 집중적으로 사용함

    → 우선 순위 감소

    

#### MLFQ: How to Change Priority

MLFQ 우선 순위 조정 알고리즘:

- 규칙 3 : 작업이 시스템에 진입할 때 작업은 가장 높은 우선 순위에 놓인다.
- 규칙 4a : 작업이 실행되는 동안 전체 time slice를 모두 사용할 경우 우선 순위가 줄어든다. (대기열에서 아래로 이동)
- 규치 4b : time slice가 가동되기 전에 작업이 CPU를 포기하는 경우 동일한 우선 순위 수준을 유지한다.

**이러한 방식으로 MLFQ는 SFJ에 근사치를 가진다.**



#### Example 1: A Single Long-Running Job

time slice가 10ms인 3-큐 스케쥴러



#### Example 2: Along Came a Short Job

가정:

- 작업 A : CPU가 많이 사용되는 장시간 작업
- 작업 B : 짧은 실행 대화형 작업 (runtime이 20ms)

A는 얼마 동안 실행되었고, B는 T=100 시간에 도착함.



#### Example 3: What About I/O?

가정:

- 작업 A : CPU가 많이 사용되는 장시간 작업
- 작업 B : I/O를 수행하기 전에 CPU가 1ms 동안만 필요한 대화형 작업

**MLFQ 접근 방식은 대화형 작업을 가장 높은 우선순위로 유지한다.**

만약 I/O요청 작업이 수 없이 들어온다면 I/O요청으로 인해 우선순위가 낮은 작업은 실행할 수 없는 상태가 된다.



------



#### The priority boost

일정 기잔 S가 지나면 시스템의 모든 작업을 맨 위 대기열로 이동한다.



#### Better Accounting

스케쥴러 게임을 어떻게 예방할 수 있을까? (프로세스가 스케줄러를 속인다)

솔루션:

규칙 4 (규칙 4a, 4b 다시 작성) : 작업이 지정된 수준에서 time allotment (시간 할당을 모두 사용하면(CPU를 포기한 횟수에 관계없이), 우선순위가 줄어든다.



#### Tuning MLFQ And Other Issues

낮은 우선순위, 긴 수량

- 높은 우선 순위 큐 → 짧은 time slice
- 낮은 우선 순위 큐 → 긴 time slice

우선 순위가 낮을 수록 CPU 사용 시간이 길어지게 만든다.



------



#### MLFQ: Summary

세분화된 MLFQ 규칙:

1. 우선 순위(A) > 우선 순위(B)이면 A가 실행된다. (B는 실행하지 않음)
2. 우선 순위(A) = 우선 순위(B)이면 A&B가 RR으로 실행된다.
3. 작업이 시스템에 진입할 때 작업은 가장 높은 우선 순위에 놓인다.
4. 작업이 지정된 수준에서 time allotment(시간 할당)을 모두 사용하면(CPU를 포기한 횟수와 관계 없이), 우선 순위가 줄어든다. (대기열에서 아래로 이동)
5. 일정 기간 S가 지나면 시스템의 모든 작업을 맨 위 대기열로 이동한다.
