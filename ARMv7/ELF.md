## 실행 파일 형식 - ELF


GCC 등의 컴파일러로 오브젝트 파일을 만들고 링커로 라이브러리를 링킹하고 나면 최종 결과물 파일이 하나 생성된다. 이것을 실행 파일이라고 부르며, 이 파일들은대부분 ELF 파일 형식으로 만들어진다. 펌웨어 바이너리는 타깃 시스템에 전원이 켜지면 자동으로 실행되는 파일 형식이므로 실행 파일 형식이라고 한다. 여기서 ELF는 Excutable and Linkable Format의 약자이다.

<br>

ELF 파일 형식은 크게 두 부분으로 구분된다. 헤더와 섹션이다. ELF 헤더는 ELF포멧이 지정하는 여러 정보들을 담고 있는 자료구조이다. 로더는 이 ELF 헤더를 읽은 후 필요한 데이터를 찾아서 메모리에 복사하고 CPU의 레지스터 값을 조정해서 파일을 실행한다.

<br>

중요한 것은 ELF 파일 포맷의 시작은 ELF 헤더라는 것과 섹션으로 나누어져 있다는 것이다.

<br>

ELF 섹션에는 이름이 있다. 섹션의 이름은 점으로 시작하는 단어이다. 

- .text : 컴파일러가 만든 기계어가 위치하는 섹션
- .rdata : 읽기 전용(read only) 데이터를 말한다. C언어의 const나 코드 안에 직접 숫자로 써 넣은 값이 여기에 위치한다.
- .data : 초기화된 전역 변수가 위치한다. 전역 변수를 선언할 때 초기화를 같이 하면 이곳에 정보가 기록됨.
- .bss : 초기화되지 않은 전역 변수가 위치합니다. 이 섹션에 위치한 전역 변수들은 나중에 0으로 초기화 됨.
- .symtab : 심벌 테이블(symbol table). 전역 변수와 함수에 대한 심벌을 저장한다. 링커가 링킹을 할 때 다른 바이너리 파일의 .rel.text와  .rel.data에 있는 심벌 정보와 이 섹션에 있는 심벌 정보를 연결해서 메모리 오프셋을 지정해준다.
- .rel.text, .rel.data : 다른 파일에 선언된 전역 변수나 함수를 호촐할 때 컴파일러는 소스 파일 내에서 해당 심벌을 찾을 수 없으므로 일단 비워두고 이 섹션에 정보를 기록한다. 이후 링커가 연결해준다.
- .debug : 해당 정보가 전역 변수나 함수 이름이면 .symtab에서 읽고 로컬 변수일 때는 이 섹션에서 읽어온다. GCC 경우 -g 옵션을 사용하면 생성됨.
- .line :  디버거로 디버깅할 때 C언어 한 줄이 어셈블리어 여러 줄로 연결되어 보여지는데 이런 정보가 기록되어있다. GCC 경우 -g 옵션을 사용하면 생성됨.
- .strtab : ELF 파일 전체에 사용되는 문자열 정보가 기록되어있음.

<br>

링커는 ELF 파일의 헤더와 셋션 정보를 읽어서 오브젝트 파일들을 하나로 묶은 다음 실행 가능한 최종 바이너리 파일을 만든다. 최종 바이너리 파일 자체도 ELF파일이다. 
실행 가능한 최종 바이너리 파일은 로더에 의해 조각 조각 분해되어 메모리에 복사된다. 윈도우나 리눅스라면 운영체제가 로더의 역할을 담당한다. 임베디드 시스템에서는 아예 이 실행 가능한 최종 바이너리 파일을 로더가 필요없게 만들거나 별도의 로더를 만들어서 먼저 실행시키고 로더가 펌웨어 바이너리 본체를 읽어서 메모리에 올리는 식으로 만든다. 어떤 식으로든 로더의 역할을 하는 절차는 임베디드시스템에서도 필요하다.
