# 1. 가상화 유형

## 전 가상화 (Full Virtualization)

전체를 가상화하느냐, 일부만 가상화하고 나머지는 실제 하드웨어를 그대로 사용하느냐에 따라 구분한다.

전 가상화를 통해 만들어진 가상 머신의 커널은 자신이 가상 머신의 커널인지 인지하지 못 한다. 전 가상화에서 Hypervisor의 역할은 '하드웨어를 전부 가상화 시켜주고 가상의 하드웨어 정보를 VM의 커널에게 전달해서 하드웨어 요청이 필요하면 실제 하드웨어에게 요청할 필요 없이 가상의 하드웨어에 요청'할 수 있도록 하는 것이다.

즉, 전 가상화는 모든 하드웨어를 전부 가상화 시켜서 논리적으로 배분하는 것이다. 하드웨어와 VM 커널 사이에 Hypervisor단이 있기는 하나, 이미 VM은 가상화된 하드웨어를 진짜 하드웨어로 인지하고 있기 때문에 실제 물리 자원에 대한 요청을 보낸다고 생각한다. 원래 시스템콜에 의해 발생해서 앱->커널->하드웨어 순으로 갔어야 흘러갔어야 하는 트랩을 Hypervisor 단에서 처리하게 되고, 하드웨어의 논리적 분배를 위한 소프트웨어적인 동작인 에뮬레이션(Emulation)까지 처리하면서 발생하는 성능저하이다. (오버헤드 발생)

다양한 OS를 올릴 수 있는 대신에 오버헤드라는 단점이 생기는 것으로 이해하면 된다.

## 반 가상화 (Para Virtualization)

전 가상화와 달리 반 가상화는 트랩과 에뮬레이션을 Hypervisor가 처리하지 않는다. 반 가상화는 하드웨어 리소스를 전부 가상화 하지 않고 일부만 가상화해서 가상화된 만큼만 분배한다. VM 밖으로 벗어나지 않고 처리할 수 있는 부분은 Guest OS가 직접 처리하고 그 외의 부분은 Hypervisor에게 넘겨줘야 하는데 이 때 Hypervisor에게 보내는 요청이 Hyper call이다. 이렇게 되면서 Hypervisor는 필요할 때만 요청을 처리해 주는 데 지나지 않으므로 전 가상화에서 발생했던 오버헤드를 줄일 수 있게 되었다. 보다시피 반 가상화는 전 가상화의 오버헤드를 줄이고자 나오게 된 개념이다.

문제는 어플리케이션이 하드웨어 레벨에 접근하기 위해서는 Hypercall을 보내야 한다는 점이다. 그러려면 어플리케이션은 자신이 가상화 상태에 있다는걸 알아야 한다. 자신이 VM인지 아닌지를 알아야 VM 커널에 System call을 보내서 자체적으로 처리할지, 하드웨어 자원에 접근하기 위해 Hyper call을 보낼지 결정할 수 있기 때문이다. 이를 위해서는 Full Virtualization과 달리 번역 과정이 없으므로 운영체제의 설계가 수정되어야 하며 이는 곧 커널 소스의 수정을 의미한다. 커널을 수정해서 하이퍼바이저에게 Hyper call을 날리면 하드웨어와 거의 'direct'라고 표현할 수 있을 정도의 직접적 커뮤니케이션이 가능해진다. 리눅스 계열은 오픈소스이기 때문에 커널 소스를 수정하면 그만이지만 Windows는 소스가 공개되지 않았으므로 개인단위로 수정할 수가 없었고, 결국 아직까지 Para virtualization을 제공하지 못하고 있다.
