# Kafka Consumer

컨슈머는 컨슈머 API와 그것으로 구성된 애플리케이션을 말한다. 일반적으로 컨슈머가 토픽을 구독(Subscribe) 혹은 읽은다(Read)고 하는데, 이는 컨슈머가 토픽 파티션에 저장된 메시지들을 가져오는 것을 말한다. 카프카 컨슈머는 아래 3가지 특징을 가진다.

- Polling 구조
- 단일 토픽의 멀티 컨슈밍
- 컨슈머 그룹

### Polling 구조

일반적인 메시징 큐는 메시지 큐에서 메시지를 Push해서 사용함. 이런 Push 방식의 단점은 메시지 큐가 컨슈머 측의 처리 성능을 염두해야 한다는 것이다.

### 단일 토픽의 멀티 컨슈밍

하나의 토픽에 서로 다른 컨슈머 애플리케이션이 동시에 구독할 수 있다. 하나의 토픽을 여러 컨슈머가 동시에 구독할 수 있다는 의미이다. 이렇게 단일 토픽에 대한 멀티 컨슈밍이 가능한 이유는 컨슈머가 메시지를 읽을 때 브로커의 메시지가 삭제되는 것이 아니라, 각 컨슈머가 어느 토픽의 어느 오프셋까지 읽어갔는 지를 컨슈머 오프셋(__consummer_offset) 이라는 토픽에 저장한다.

컨슈머 오프셋을 사용함으로써 컨슈머 애플리케이션이 메시지 구독 중 중단되었다가 다시 구동되는 경우, 컨슈머 오프셋에 저장된 정보를 통해 자신이 어디서부터 메시지를 읽어야하는 지 알 수 있다. 즉, 컨슈머 상태와 관계없이 안정적인 메시지 구독이 가능해진다.

### 컨슈머 그룹

브로커는 성능을 위해 하나의 토픽을 여러 파티션으로 병렬 구성하여 처리한다. 하지만 둘 이상의 파티션을 하나의 컨슈머로만 처리한다면 성능상의 문제가 발생할 수 있다. 그렇기 때문에 컨슈머는 하나 이상의 컨슈머가 컨슈머 그룹(Consumer Group)을 구성하여 하나의 토픽을 구독할 수 있도록 한다.

컨슈머 그룹 내의 컨슈머는 토픽 파티션의 소유권(구독권)을 나뉘 갖는다. 같은 컨슈머 그룹의 컨슈머들은 소유권을 가진 파티션만 구독한다.

그렇다면 컨슈머 그룹에 컨슈머가 추가되거나, 이탈하게 되면 컨슈머 그룹 내부에서 파티션의 소유권이 재조정된다. 이러한 파티션 소유권 재조정을 리밸런싱(Rebalancing)이라고 한다. 리밸런싱은 컨슈머 그룹 내에 특정 컨슈머의 상태가 변경되더라도 다른 컨슈머들이 유연하고 안정적으로 토픽을 구독할 수 있도록 도와주는 기능이다. 

## 컨슈머 예제

컨슈머 생성에 필수 설정으로 아래 3가지가 있다.

- `bootstrap.servers` : 메타데이터 초기화를 위한 설정
- `group.id` : 컨슈머의 그룹 아이디
- `key.deserializer.class` : 메시지의 키를 역직렬화하기 위한 설정
- `value.deserializer.class` : 메시지의 값을 역직렬화하기 위한 설정

위 설정 외에도 다양한 설정이 있다. 요구되는 컨슈밍 환경이나 성능 등에 따라 다양하게 설정될 수 있다. 그 중 가장 자주 고려되는 몇 가지 설정을 살펴본다.

- `heartbeat.interval.ms` & `session.timeout.ms`
    
    위 설정은 컨슈머의 상태를 나타내는 것과 관련된 설정이다. 하트비트 설정은 컨슈머가 자신이 정상 구동 중임을 특정 브로커에 알려주는 주기이고, 세션 타입아웃 설정은 브로커가 컨슈머의 하트비트 신호를 기다리는 주기 이다. 만약 설정된 세션 타임아웃 시간 중에 특정 컨슈머의 하트비트 신호를 받지 못하면 브로커는 해당 컨슈머가 정상구동이 아님으로 판단하고 리밸런싱을 시작한다. 
    
    이처럼 두 가지 설정은 서로 연관되어 있기 때문에 하트비트 설정과 세션 타임아웃 설정을 약 1:3 비율로 지정한다. 
    
- `max.partition.fetch.bytes`
    
    위 설정은 파티션 별로 컨슈머가 한번에 가져오는 메시지의 최대 크기를 지정하는 설정이다. 따라서 컨슈머는 [ 구독하는 파티션 수 x `max.partition.fetch.bytes` ] 의 값만큼 메모리를 가지고 있어야 한다. 추가로 이 섷정은 컨슈머가 poll 메서드를 통해 생성하는 ConsumerRecords의 최대 크기와 관련이 있다.
    
    위 설정은 브로커의 `max.message.bytes` 설정과 매우 깊은 관련이 있다. 만약 브로커의 `max.message.bytes` 설정 값이 `max.partition.fetch.bytes` 보다 크고, 그 설정 값의 크기를 가지는 메시지가 브로커로 발생되어 있다면 컨슈머는 그 메시지를 구독할 수 없게 된다.
    
- `auto.offset.reset`
    
    컨슈머는 파티션의 오프셋을 기준으로 메시지를 구독한다. 그런데 컨슈머가 처음 컨슈머 그룹을 구성하여 구동되거나, 컨슈머가 오랜 기간동안 중단되었다가 구동되어 오프셋에 대응되는 메시지가 브로커에서 삭제된 경우(컨슈머가 오프셋 정보를 가지고 있지 않은 경우) 에는 해당 정보를 초기화해야 한다. 초기화 방법은 `auto.offset.reset` 설정에 따라 아래 3가지가 있다.
    
    - earliest : 파티션에 저장된 메시지의 가장 처음부터
    - latest : 구독 후 파티션에 처음 들어오는 메시지부터
    - none : 초기화하지 않고 에러 발생
- `enable.auto.commit`
    
    컨슈머는 머시지를 브로커로부터 가져와서 처리한 뒤 처리 완료한 메시지의 오프셋 정보를 컨슈머 로프셋(__consumer_offset) 으로 커밋 한다. 이를 오프셋 커밋이라고 한다. 이러한 오프셋 커밋을 자동으로 할지, 수동으로 할지에 관한 설정이 `enable.auto.commit` 설정이다. 
    
    자동 커밋(true)인 경우 `auto.commit.interval.ms` 설정 주기에 따라 자동으로 오프셋을 커밋한다. 반대로 수동 커밋(false)인 경우 컨슈머 객체의 commitAsync() 혹은 commitSync()를 통해 직접 커밋을 해야 한다. 대부분은 수동 커밋을 사용하여 메시지 처리가 완료되었음을 직접 관리한다.

출처: https://always-kimkim.tistory.com/entry/kafka101-consumer
